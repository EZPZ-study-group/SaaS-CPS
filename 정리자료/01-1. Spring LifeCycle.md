너무 길어지는 것 같아서 파일 분할. 추후, 마크다운 형태로 문서 변경 필요

1. Spring MVC LifeCycle
   ![Spring MVC 라이프사이클](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2152594E590431631F)
   참고: https://all-record.tistory.com/164


2. String Bean LifeCycle
   * new 로 만드는 객체는 Spring Bean이 아님.(IoC 컨테이너가 관리하는 객체를 Bean이라고 함.)
  #### Spring Bean의 life cycle
   > Spring IoC Container 생성 -> Spring Bean 생성 -> 의존관계 주입 -> 초기화 콜백 메소드 호출 -> [사용]-> 소멸 전 콜백 메소드 호출 -> Spring 종료

  흔히 의존설정을 하는 방법은 아래와 같음
  
    1. 생성자: 객체의 생성과 의존관계 주입이 동시에 일어남
    2. Setter, Field: 객체의 생성 -> 의존관계 주입으로 라이프사이클 분리되어있음

##### ex) 생성자를 통한 객체 주입 방법
```java
@Controller
public class TestController {
  private final TestService testService;
  public testController(TestService testService){
    this.testService = testService;
  }
}
------------------------------------------------------
public class main{
  TestController t = new TestController(); // 컴파일에러
  TestController tt = new TestControler(new TestService()); // 정상 생성
}
```
무슨말이냐면, Java에서 new 연산을 하면 생성자가 자동으로 호출 됨.
이 방법도 이점이 있는데
1. null을 주입하지 않는 이상 Npe발생하지 않음.
2. 의존관계를 노출시켰기 때문에 컴파일 단계에서 오류를 잡아낼 수 있음.

##### ex) setter를 통한 객체 주입 방법
```java
@Controller
public TestController {
  private TestService testService;
  @Autowired
  public void setTestController(TestService testService){
    this.testService = testService;
  }
}
```
생성자를 사용했을 때와는 다르게 Controller 객체를 만들 때 Service객체와의 의존 관계가 없어도 Controller를 생성할 수 있음.


Spring Bean 초기화 및 종료 방법 3가지
1. 인터페이스 활용( InitializingBean, DisposableBean )
  ```java
    public class Bean1 implements InitializingBean, DisposableBean {
      @Override
      public void afterPropertiesSet() throws Exception {
        //초기화 콜백(의존관계 주입 후 호출)
      }

      @Override
      public void destroy() throws Exception {
        // 소멸 전 콜백(메모리 반납, 연결 종료와 같은 과정)
      }
    }
  ```
  단점) 스프링 초창기에 나온 방법으로, 현재는 거의 사용하지 않음.
  * InitializingBean, DisposableBean 인터페이스들은 스프링 전용 인터페이스
  * 초기화, 소멸 메소드를 오버라이드 하기 때문에 메소드명 변경 불가
  * 코드를 커스터마이징 할 수 없는 외부 라이브러리에 적용 불가
    
2. Bean 등록 시, 초기화 / 소멸 메소드 지정
   ```java
     public class Bean2 {
       public void initialize() throws Exception {
         //초기화 콜백(의존관계 주입 후 호출)
       }
       public void close() throws Exception {
         // 소멸 전 콜백(메모리 반납, 연결 종료와 같은 과정)
       }
     }

     @Configuration
     class LifeCycleConf {
       @Bean(initMethod = "initialize", destroyMethod = "close")
       public Bean2 bean2(){
         // 생략
       }
     }
   ```
   장점)
   * 메소드명 자유롭게 지정 가능
   * 스프링 코드에 의존하지 않음
   * 설정 정보를 사용하므로, 외부 라이브러리에서도 적용 가능
   단점)
   * initMethod와 destroyMethod를 직접 지정해야되서 귀찮음
   특징)
   * 라이브러리들의 대부분은 종료 메소드명이 close 혹은 shutdown인데 @Bean의 destoryMethod는 기본값이 inferred로 등록 되므로
     close, shutdown이라는 이름의 메소드가 종료 메소드라고 추론하여 자동으로 호출된다.
     즉, 종료 메소드를 원하지 않아도 호출되기 때문에 명시적으로 destoryMethod = "" 와 같이 지정해주어야한다.
     
3. Anntation Callback 등록
  ```java
    public Bean3 {
      @PostConstruct
      public void initialize() throws Exception {
        //초기화 콜백(의존관계 주입 후 호출)
      }
      @PreDestory
      public void close() throws Exception {
        // 소멸 전 콜백(메모리 반납, 연결 종료와 같은 과정)
      }
    }
  ```
  장점)
  * 최신 스프링에서 권장하는 방식
  * 어노테이션만 붙이면 되서 간편
  * 스프링에 종속적인 기술이 아닌 "JSR-250" 자바 표준임.
  * 컴포넌트 스캔과 잘 어울림
  단점)
  * 커스터마이징이 불가능한 외부 라이브러리에서 적용이 불가

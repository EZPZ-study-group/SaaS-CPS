# Spring Boot

|    수정일자    | 수정자 | 수정내용 |
|:-------------:|:---:|:-----|
| 2023.09.03 | 유승민 | 최초작성 |
| 2023.10.23 | 유승민 | Annotation 별 특징 및 차이점 추가 |

참고: https://docs.spring.io/spring-boot/docs/3.2.0-SNAPSHOT/reference/html/auto-configuration-classes.html#appendix.auto-configuration-classes

### 목차
0. [SpringFrameWork](#0-spring-framework)
1. [SpringBoot의 시작](#1-springboot의-시작)
2. [Annotation [`@SpringBootApplication`]](#2-annotation-springbootapplication)
3. [Annotation [`@SpringBootConfiguration`]](#3-annotation-springbootconfiguration)
4. [Annotation [`@Configuration`]](#4-annotation-configuration)
5. [Annotation [`@EnableAutoConfiguration`]](#5-annotation-enableautoconfiguration)
6. [Annotation [`@AutoConfigurrationPackage`]](#6-annotation-autoconfigurrationpackage);
7. [Annotation 별 특징 및 차이점](#7-annotation-별-특징-및-차이점)
---
# 0. Spring Framework

> ### Spring Framework
> 엔터프라이즈용 Java 애플리케이션 개발을 편하게 할 수 있게 해주는 오픈소스 경량급 애플리케이션 프레임워크

> ### Spring Framework의 특징들
> <details>
> <summary>1. POJO(Plain Old Java Object)</summary>
> 순수 Java만을 통해서 생성한 객체<br>
> 순수 Java 만을 사용한다는 것은 Java 및 Java의 스펙에 정의된 기술만 사용한다
>
> ```java
> public class Person {
>     private String name;
>     private int age;
>
>     public String getName() {
>         return name;
>     }
>
>     public void setName(String name) {
>         this.name = name;
>     }
>
>     public int getAge() {
>         return age;
>     }
>
>     public void setAge(int age) {
>         this.age = age;
>     }
> }
> ```
> </details>
> <details>
> <summary>2. IoC / DI</summary>
> 
> ##### 아래는 평범한 Java 소스
> A클래스를 생성하여 내부 methodOfA를 실행시키면, B클래스에 들어있는 method가 실행 됨.<br>
> 만약, A클래스에서 B클래스가 아닌 C클래스를 사용하기 위해서는 methodOfA를 수정해야만 함.
> ```java
> public class A {
>     public void methodOfA() {
>         B b = new B();
>         b.method();
>     }
> }
> 
> public class B {
>    public void method(){
>        System.out.println("B Class");
>    }
> }
> ```
> 
> ##### 하지만 아래처럼 만들었다면?
> ```java
> public interface I {
>    void method();
> }
> 
> public class A {
>    private I i;
>
>    public A(I i){
>        this.i = i;
>    }
>
>    public void methodOfA() {
>        i.method();
>    }
> }
> 
> public class B implements I{
>    @Override
>    public void method() {
>        System.out.println("B Class");
>    }
> }
> 
> ```
> 
> </details>
> <details>
> <summary>3. AOP(Aspect Oriented Programming)</summary>
> 개인적으로 다른건 다 말장난이라고 생각하고, 이게 핵심이지 않을까 생각함.
> </details>

> ### Spring Framework의 단점!
> 설정하는게 복잡해도 너~무 복잡함.<br>
> 예시로 Spring을 이용한 Web Project의 가장 중요한(?) dispather-servlet 설정하는 부분을 보면..
> ```xml
> <web-app>
>    <listener>
>        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
>    </listener>
>    <context-param>
>        <param-name>contextConfigLocation</param-name>
>        <param-value>/WEB-INF/root-context.xml</param-value>
>    </context-param>
>    <servlet>
>        <servlet-name>app</servlet-name>
>        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
>        <init-param>
>            <param-name>contextConfigLocation</param-name>
>            <param-value>/WEB-INF/app-context.xml</param-value>
>        </init-param>
>        <load-on-startup>1</load-on-startup>
>    </servlet>
>    <servlet-mapping>
>        <servlet-name>app</servlet-name>
>        <url-pattern>/app/*</url-pattern>
>    </servlet-mapping>
> </web-app>
> ```

---

# 1. SpringBoot의 시작
SpringBoot는 Spring 설정이 너무 귀찮았던 나머지 Annotation 기반의 Auto configure 기능을 통해 많은 설정들을 자동화,<br> 
개발자들은 비즈니스로직에 집중 할 수 있도록 만든 프로젝트

SpringBoot는 아래 코드만 있으면 시작됨

``` java
@SpringBootApplication
public class MsaCpsApplication {
	public static void main(String[] args) {
		SpringApplication.run(MsaCpsApplication.class, args);
	}

}
```
와! 스프링 부트 끝!<br>
하기 전에 코드의 상단부분에 있는 `@SpringBootApplication`이 뭐길래 저거 하나로 SpringBoot가 동작하는지 확인<br>

ps. 어노테이션에 대한 내용이므로, 어노테이션이 어떤 원리로 동작하는지 내용이 무엇인지 알아야 수월하므로 어노테이션에 대해 따로 정리를 해 두었습니다.

---
# 1. Annotation


---

# 2. Annotation [`@SpringBootApplication`]
`@SpringBootApplication`를 열어보면 주요 어노테이션 3개를 확인할 수 있다.

1. `@SpringBootConfiguration`
2. `@EnableAutoConfiguration`
3. `@ComponentScan`

``` java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {

... 생략 ...
```
---
# 3. Annotation [`@SpringBootConfiguration`]
특이사항으로는 `@Configuration`으로 구성되어 있고<br>
설명을 보면 `@SpringBootConfiguration`은 하나만 있어야 한다고 함<br>
Application should only ever include <em>one</em> {@code @SpringBootConfiguration} 

```java
/**
 * Indicates that a class provides Spring Boot application
 * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's
 * standard {@code @Configuration} annotation so that configuration can be found
 * automatically (for example in tests).
 * <p>
 * Application should only ever include <em>one</em> {@code @SpringBootConfiguration} and
 * most idiomatic Spring Boot applications will inherit it from
 * {@code @SpringBootApplication}.
 *
 * @author Phillip Webb
 * @author Andy Wilkinson
 * @since 1.4.0
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
@Indexed
public @interface SpringBootConfiguration {

    /**
     * Specify whether {@link Bean @Bean} methods should get proxied in order to enforce
     * bean lifecycle behavior, e.g. to return shared singleton bean instances even in
     * case of direct {@code @Bean} method calls in user code. This feature requires
     * method interception, implemented through a runtime-generated CGLIB subclass which
     * comes with limitations such as the configuration class and its methods not being
     * allowed to declare {@code final}.
     * <p>
     * The default is {@code true}, allowing for 'inter-bean references' within the
     * configuration class as well as for external calls to this configuration's
     * {@code @Bean} methods, e.g. from another configuration class. If this is not needed
     * since each of this particular configuration's {@code @Bean} methods is
     * self-contained and designed as a plain factory method for container use, switch
     * this flag to {@code false} in order to avoid CGLIB subclass processing.
     * <p>
     * Turning off bean method interception effectively processes {@code @Bean} methods
     * individually like when declared on non-{@code @Configuration} classes, a.k.a.
     * "@Bean Lite Mode" (see {@link Bean @Bean's javadoc}). It is therefore behaviorally
     * equivalent to removing the {@code @Configuration} stereotype.
     * @return whether to proxy {@code @Bean} methods
     * @since 2.2
     */
    @AliasFor(annotation = Configuration.class)
    boolean proxyBeanMethods() default true;
```
---
# 4. Annotation [`@Configuration`]
결국 `@Configuration`도 `@Component`
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {

	/**
	 * Explicitly specify the name of the Spring bean definition associated with the
	 * {@code @Configuration} class. If left unspecified (the common case), a bean
	 * name will be automatically generated.
	 * <p>The custom name applies only if the {@code @Configuration} class is picked
	 * up via component scanning or supplied directly to an
	 * {@link AnnotationConfigApplicationContext}. If the {@code @Configuration} class
	 * is registered as a traditional XML bean definition, the name/id of the bean
	 * element will take precedence.
	 * @return the explicit component name, if any (or empty String otherwise)
	 * @see AnnotationBeanNameGenerator
	 */
	@AliasFor(annotation = Component.class)
	String value() default "";

	/**
	 * Specify whether {@code @Bean} methods should get proxied in order to enforce
	 * bean lifecycle behavior, e.g. to return shared singleton bean instances even
	 * in case of direct {@code @Bean} method calls in user code. This feature
	 * requires method interception, implemented through a runtime-generated CGLIB
	 * subclass which comes with limitations such as the configuration class and
	 * its methods not being allowed to declare {@code final}.
	 * <p>The default is {@code true}, allowing for 'inter-bean references' via direct
	 * method calls within the configuration class as well as for external calls to
	 * this configuration's {@code @Bean} methods, e.g. from another configuration class.
	 * If this is not needed since each of this particular configuration's {@code @Bean}
	 * methods is self-contained and designed as a plain factory method for container use,
	 * switch this flag to {@code false} in order to avoid CGLIB subclass processing.
	 * <p>Turning off bean method interception effectively processes {@code @Bean}
	 * methods individually like when declared on non-{@code @Configuration} classes,
	 * a.k.a. "@Bean Lite Mode" (see {@link Bean @Bean's javadoc}). It is therefore
	 * behaviorally equivalent to removing the {@code @Configuration} stereotype.
	 * @since 5.2
	 */
	boolean proxyBeanMethods() default true;

	/**
	 * Specify whether {@code @Bean} methods need to have unique method names,
	 * raising an exception otherwise in order to prevent accidental overloading.
	 * <p>The default is {@code true}, preventing accidental method overloads which
	 * get interpreted as overloaded factory methods for the same bean definition
	 * (as opposed to separate bean definitions with individual conditions etc).
	 * Switch this flag to {@code false} in order to allow for method overloading
	 * according to those semantics, accepting the risk for accidental overlaps.
	 * @since 6.0
	 */
	boolean enforceUniqueMethods() default true;

}
```

> <details>
> <summary>Q1. 그렇다면 Configuration과 Component를 구분해서 사용 할 필요가 있나..?</summary>
> `Configuration`의 설명을 보면
> 
> > Specify whether {@code @Bean} methods should get proxied in order to enforce bean lifecycle behavior, e.g. to return shared singleton bean instances even in case of direct {@code @Bean} method calls in user code.<br>
> > Bean 라이프사이클 동작을 시행하기 위해 {@code @Bean} 메소드가 프록시되어야 하는지 여부를 지정하십시오. 사용자 코드에서 직접 {@code @Bean} 메서드를 호출하는 경우에도 공유 싱글톤 Bean 인스턴스를 반환합니다.
> `Configuration`은 Singleton
> </details>

---
# 5. Annotation [`@EnableAutoConfiguration`]

Spring Boot 자동 설정의 핵심인 녀석 <br>
분명 어디선가 자동 설정을 할텐데.. <br>
> spring-boot-autoconfigure 내 `spring.factories`였는데,<br>
> Spring Boot 버전이 올라가면서 `org.springframework.boot.autoconfigure.AutoConfiguration.imports`로 위치를 바꾼건가?

`org.springframework.boot.autoconfigure.AutoConfiguration.imports`안에 `org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration` 이게 있음.<br>

> <details>
> <summary>Q1. 아니 근데, 저기안에 있는애를 다 자동설정하면 에러 빵빵 터지겠네??</summary>
> 해당 클래스를 뜯어보면, 아래와 같음
> 
> ```java
> /**
>  * {@link EnableAutoConfiguration Auto-configuration} for the Spring
>  * {@link DispatcherServlet}. Should work for a standalone application where an embedded
>  * web server is already present and also for a deployable application using
>  * {@link SpringBootServletInitializer}.
>  *
>  * @author Phillip Webb
>  * @author Dave Syer
>  * @author Stephane Nicoll
>  * @author Brian Clozel
>  * @since 2.0.0
>  */
> @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
> @AutoConfiguration(after = ServletWebServerFactoryAutoConfiguration.class)
> @ConditionalOnWebApplication(type = Type.SERVLET) //Project의 타입이 SERVLET이고, ( WEB도 Servlet )
> @ConditionalOnClass(DispatcherServlet.class)      //DispatcherServlet 클래스가 Bean에 등록이 되어 있으면
> public class DispatcherServletAutoConfiguration {
> ... 생략 ...
> ```
> </details>

---
*** 6번 항목 추가 필요
*** 아래 개선 필요
# 7. Annotation 별 특징 및 차이점
1. @Component vs @ Bean
   > @Component: 개발자가 직접 작성한 컨트롤이 가능한 Class를 Bean으로 등록하기 위한 어노테이션 ( 싱글톤으로 등록 )<br>
   > 단, @Scope("Prototype")이라는 어노테이션을 통해 싱글톤이 아닌 상태로 Bean을 만들 수 있다.

   > @Bean: 개발자가 컨트롤 불가능한 외부 라이브러리들을 Bean으로 등록하기 위한 어노테이션
   > ```java
   > //...중략
   > @Configuration
   > public class ApplicationConfig {
   >     @Bean
   >     public MyClass myClass(String param){
   >         return new MyClass(param);
   >     }
   > }
   > //...중략
   > ```
   >
   > ps. SimpleJson같은거 이렇게 만들어서 쓰면 있어보이고 편하겠는데...?
2. @Controller vs @RestController
   |    어노테이션    | 공통점                                    | 차이점 |
   |:---------------:|:------------------------------------------|:-------------------------------|
   | @Controller     | Spring의 Controller를 나타내는 어노테이션   | View Return이 주 목적인 Controller에 사용<br>(@ResponseBody 어노테이션을 사용하여 @RestController와 같이 사용 가능)|
   | @RestController |                                           | 기본적으로 @ResponseBody의 의미를 담고있으며, data의 return이 주 목정<br>* <span style="color: red">Spring 4.0.1부터 제공</span>|
3. @ResponseBody
   > HttpMessageConverter를 이용하여 Json 혹은 xml로 응답할 수 있도록 처리해주는 어노테이션
   > 문자열을 리턴하면 http response header가 아닌, response body에 들어간다.
   > 객체를 return하는 경우, jsonson라이브러리에 의해 문자열로 변환되어 전송
   > context에 설정 되어있는 viewResolver를 무시(?)
4. @Controller vs @Service vs @Repository
   > 각 클래스의 역할을 명확하게 구분 짓기 위해 디테일하게 나눠 둔 것으로 보여짐.
   
   |    어노테이션    | 공통점                                      | 차이점 |
   |:---------------:|:---------------------------------------------|:-------------------------------|
   | @Controller     | @Component에 의하여 자동으로 Spring Bean등록   | Dispatcher는 @Controller 어노테이션을 보유한 클래스들을 확인하여 @RequestMapping이 있는 메서드들을 확인 합 하여 요청을 처리|
   | @Service        |                                              | 비즈니스 로직이 있으며, 저장소 계층을 사용.(외에는 별 다른 특징 없음)|
   | @Repository     |                                              | 특정 예외를 잡아, Spring의 unchecked예외로 다시 던짐<br>PersistenceExceptionTranslationPostProcessor를 구현해야하며, 즉, 상세예외를 잡으면 스프링의 DataAccessException으로 다시 던질 수 있음.|

##### DDD(Eveans, 2003)에 정의 된 내용
@Controller: ???<br>
@Service: 캡슐화된 상태 없이 모델에서 단독으로 독립된 인터페이스로 제공되는 작업<br>
@Repository: 저장, 검색, 객체 컬렉션을 에뮬레이트하는 검색 행위를 캡슐화하는 메커니즘<br>

5. @Autowired vs @Inject vs @Qualifier vs @Resource
   |    어노테이션    | 공통점                                      | 차이점 |
   |:---------------:|:---------------------------------------------|:-------------------------------|
   | @Autowired     | Bean을 사용할 수 있도록 주입시켜주는 어노테이션 | 1. Type에 따라서 Bean 주입<br>2. Name에 따라 주입(@Qualifier 어노테이션을 같이 사용해야 함)<br><span style="color: red">* Spring의 어노테이션</span>|
   | @Inject        |                                              | @Autowired와 유사<br>Java의 Annotation( Resource와 마찬가지로 framework에 종속적이지 않음 )|
   | @Qualifier     |                                              | 단독으로 사용될 수 없음.(Autowired와 같이 사용)<br>같은타입의 Bean이 있을 때, 원하는 ID를 지정하여 해당 Bean이 주입되도록 하는 어노테이션|
   | @Resource      |                                              | 1. Name에 따라 주입<span style="color: red"><br>* JSR-250표준 Annotation<br>* 특정 framework에 종속적인 어플리케이션이 되기 싫으면 @Resource 권장<br>* jsr250-api.jar 파일 추가하여 사용 가능</span>|

    > @Autowired
    > 찾는 순서
    > > 타입 -> 이름 -> @Qualifier -> 실패
    
    > @Inject
    > > 찾는 순서
    > > 타입 -> @Qualifier -> 이름 -> 실패
    
    > @Resource
    > > 찾는 순서
    > > 이름 -> 타입 -> @Qualifier -> 실패


